{"ast":null,"code":"'use client';\n\nimport { createContext, Component, createElement, useContext, useState, useMemo, forwardRef } from 'react';\nconst ErrorBoundaryContext = createContext(null);\nconst initialState = {\n  didCatch: false,\n  error: null\n};\n\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);\n    this.state = initialState;\n  }\n\n  static getDerivedStateFromError(error) {\n    return {\n      didCatch: true,\n      error\n    };\n  }\n\n  resetErrorBoundary() {\n    const {\n      error\n    } = this.state;\n\n    if (error !== null) {\n      var _this$props$onReset, _this$props;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {\n        args,\n        reason: \"imperative-api\"\n      });\n      this.setState(initialState);\n    }\n  }\n\n  componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n\n    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      didCatch\n    } = this.state;\n    const {\n      resetKeys\n    } = this.props; // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,\n    // we'd end up resetting the error boundary immediately.\n    // This would likely trigger a second error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.\n\n    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onReset2, _this$props3;\n\n      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {\n        next: resetKeys,\n        prev: prevProps.resetKeys,\n        reason: \"keys\"\n      });\n      this.setState(initialState);\n    }\n  }\n\n  render() {\n    const {\n      children,\n      fallbackRender,\n      FallbackComponent,\n      fallback\n    } = this.props;\n    const {\n      didCatch,\n      error\n    } = this.state;\n    let childToRender = children;\n\n    if (didCatch) {\n      const props = {\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n\n      if (typeof fallbackRender === \"function\") {\n        childToRender = fallbackRender(props);\n      } else if (FallbackComponent) {\n        childToRender = createElement(FallbackComponent, props);\n      } else if (fallback !== undefined) {\n        childToRender = fallback;\n      } else {\n        {\n          console.error(\"react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop\");\n        }\n        throw error;\n      }\n    }\n\n    return createElement(ErrorBoundaryContext.Provider, {\n      value: {\n        didCatch,\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      }\n    }, childToRender);\n  }\n\n}\n\nfunction hasArrayChanged() {\n  let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));\n}\n\nfunction assertErrorBoundaryContext(value) {\n  if (value == null || typeof value.didCatch !== \"boolean\" || typeof value.resetErrorBoundary !== \"function\") {\n    throw new Error(\"ErrorBoundaryContext not found\");\n  }\n}\n\nfunction useErrorBoundary() {\n  const context = useContext(ErrorBoundaryContext);\n  assertErrorBoundaryContext(context);\n  const [state, setState] = useState({\n    error: null,\n    hasError: false\n  });\n  const memoized = useMemo(() => ({\n    resetBoundary: () => {\n      context.resetErrorBoundary();\n      setState({\n        error: null,\n        hasError: false\n      });\n    },\n    showBoundary: error => setState({\n      error,\n      hasError: true\n    })\n  }), [context.resetErrorBoundary]);\n\n  if (state.hasError) {\n    throw state.error;\n  }\n\n  return memoized;\n}\n\nfunction withErrorBoundary(component, errorBoundaryProps) {\n  const Wrapped = forwardRef((props, ref) => createElement(ErrorBoundary, errorBoundaryProps, createElement(component, { ...props,\n    ref\n  }))); // Format for display in DevTools\n\n  const name = component.displayName || component.name || \"Unknown\";\n  Wrapped.displayName = \"withErrorBoundary(\".concat(name, \")\");\n  return Wrapped;\n}\n\nexport { ErrorBoundary, ErrorBoundaryContext, useErrorBoundary, withErrorBoundary };","map":{"version":3,"names":["createContext","Component","createElement","useContext","useState","useMemo","forwardRef","ErrorBoundaryContext","initialState","didCatch","error","ErrorBoundary","constructor","props","resetErrorBoundary","bind","state","getDerivedStateFromError","_this$props$onReset","_this$props","_len","arguments","length","args","Array","_key","onReset","call","reason","setState","componentDidCatch","info","_this$props$onError","_this$props2","onError","componentDidUpdate","prevProps","prevState","resetKeys","hasArrayChanged","_this$props$onReset2","_this$props3","next","prev","render","children","fallbackRender","FallbackComponent","fallback","childToRender","undefined","console","Provider","value","a","b","some","item","index","Object","is","assertErrorBoundaryContext","Error","useErrorBoundary","context","hasError","memoized","resetBoundary","showBoundary","withErrorBoundary","component","errorBoundaryProps","Wrapped","ref","name","displayName","concat"],"sources":["C:/Users/mehat/Desktop/PMT/frontend/node_modules/react-error-boundary/dist/react-error-boundary.development.esm.js"],"sourcesContent":["'use client';\nimport { createContext, Component, createElement, useContext, useState, useMemo, forwardRef } from 'react';\n\nconst ErrorBoundaryContext = createContext(null);\n\nconst initialState = {\n  didCatch: false,\n  error: null\n};\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);\n    this.state = initialState;\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      didCatch: true,\n      error\n    };\n  }\n  resetErrorBoundary() {\n    const {\n      error\n    } = this.state;\n    if (error !== null) {\n      var _this$props$onReset, _this$props;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {\n        args,\n        reason: \"imperative-api\"\n      });\n      this.setState(initialState);\n    }\n  }\n  componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  }\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      didCatch\n    } = this.state;\n    const {\n      resetKeys\n    } = this.props;\n\n    // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,\n    // we'd end up resetting the error boundary immediately.\n    // This would likely trigger a second error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.\n\n    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onReset2, _this$props3;\n      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {\n        next: resetKeys,\n        prev: prevProps.resetKeys,\n        reason: \"keys\"\n      });\n      this.setState(initialState);\n    }\n  }\n  render() {\n    const {\n      children,\n      fallbackRender,\n      FallbackComponent,\n      fallback\n    } = this.props;\n    const {\n      didCatch,\n      error\n    } = this.state;\n    let childToRender = children;\n    if (didCatch) {\n      const props = {\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n      if (typeof fallbackRender === \"function\") {\n        childToRender = fallbackRender(props);\n      } else if (FallbackComponent) {\n        childToRender = createElement(FallbackComponent, props);\n      } else if (fallback !== undefined) {\n        childToRender = fallback;\n      } else {\n        {\n          console.error(\"react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop\");\n        }\n        throw error;\n      }\n    }\n    return createElement(ErrorBoundaryContext.Provider, {\n      value: {\n        didCatch,\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      }\n    }, childToRender);\n  }\n}\nfunction hasArrayChanged() {\n  let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));\n}\n\nfunction assertErrorBoundaryContext(value) {\n  if (value == null || typeof value.didCatch !== \"boolean\" || typeof value.resetErrorBoundary !== \"function\") {\n    throw new Error(\"ErrorBoundaryContext not found\");\n  }\n}\n\nfunction useErrorBoundary() {\n  const context = useContext(ErrorBoundaryContext);\n  assertErrorBoundaryContext(context);\n  const [state, setState] = useState({\n    error: null,\n    hasError: false\n  });\n  const memoized = useMemo(() => ({\n    resetBoundary: () => {\n      context.resetErrorBoundary();\n      setState({\n        error: null,\n        hasError: false\n      });\n    },\n    showBoundary: error => setState({\n      error,\n      hasError: true\n    })\n  }), [context.resetErrorBoundary]);\n  if (state.hasError) {\n    throw state.error;\n  }\n  return memoized;\n}\n\nfunction withErrorBoundary(component, errorBoundaryProps) {\n  const Wrapped = forwardRef((props, ref) => createElement(ErrorBoundary, errorBoundaryProps, createElement(component, {\n    ...props,\n    ref\n  })));\n\n  // Format for display in DevTools\n  const name = component.displayName || component.name || \"Unknown\";\n  Wrapped.displayName = \"withErrorBoundary(\".concat(name, \")\");\n  return Wrapped;\n}\n\nexport { ErrorBoundary, ErrorBoundaryContext, useErrorBoundary, withErrorBoundary };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}